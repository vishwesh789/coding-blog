{"pageProps":{"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"If you're building a Node.js application that will be deployed using Docker, you'll likely need to make use of environment variables to provide configuration details such as database URLs, API keys, and other sensitive data. In this article, we'll explore how to use environment variables with Dockerized Node.js applications.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"What Are Environment Variables?\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Environment variables are variables that are available to your application at runtime and can be used to store configuration information, such as database connection strings, API keys, and other sensitive data. They are set outside of the application code, usually in the operating system or a configuration file, and are accessed using the \", _jsx(_components.strong, {\n        children: \"process.env\"\n      }), \" object in Node.js.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Why Use Environment Variables?\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using environment variables to store configuration information has a number of benefits, including:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Security: sensitive information can be kept separate from the application code, reducing the risk of data breaches and unauthorized access.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Flexibility: environment variables can be changed without having to modify the application code, making it easier to deploy your application across different environments.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Reproducibility: environment variables can be used to ensure that the application runs consistently across different machines and environments.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Setting Environment Variables in Docker\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Docker provides several ways to set environment variables for your containerized applications. The most common ways are:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.strong, {\n        children: \"Using the ENV Instruction in the Dockerfile\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.strong, {\n        children: \"ENV\"\n      }), \" instruction in the Dockerfile is used to set environment variables that will be available to the container at runtime. For example, to set the \", _jsx(_components.strong, {\n        children: \"NODE_ENV\"\n      }), \" environment variable to \\\"production\\\", you would add the following line to your Dockerfile:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"ENV NODE_ENV=production\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.strong, {\n        children: \"Using the --env Flag When Running the Container\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can also set environment variables when running the container using the \", _jsx(_components.strong, {\n        children: \"--env\"\n      }), \" flag followed by the variable name and value. For example, to set the \", _jsx(_components.strong, {\n        children: \"PORT\"\n      }), \" environment variable to \\\"8080\\\", you would run the container with the following command:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"docker run --env PORT=8080 my-app\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.strong, {\n        children: \"Using a .env File\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can also use a \", _jsx(_components.strong, {\n        children: \".env\"\n      }), \" file to set environment variables for your Dockerized application. To use this method, create a file called \", _jsx(_components.strong, {\n        children: \".env\"\n      }), \" in the root directory of your project and add the variable name and value pairs, separated by an equals sign:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsxs(_components.code, {\n        className: \"language-plaintext\",\n        children: [_jsx(_components.span, {\n          className: \"code-line\",\n          children: \"DATABASE_URL=mongodb://localhost:27017/mydb\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"API_KEY=abc123\\n\"\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, in your Dockerfile, include the following line to copy the \", _jsx(_components.strong, {\n        children: \".env\"\n      }), \" file into the container:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"COPY .env .\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Accessing Environment Variables in Node.js\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Once you've set environment variables for your Dockerized Node.js application, you can access them using the \", _jsx(_components.strong, {\n        children: \"process.env\"\n      }), \" object in your Node.js code. For example, to access the \", _jsx(_components.strong, {\n        children: \"PORT\"\n      }), \" environment variable, you would use the following code:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-javascript\",\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"const\"\n          }), \" port \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" process\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token property-access\",\n            children: \"env\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token constant\",\n            children: \"PORT\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"||\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"3000\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This code sets the \", _jsx(_components.strong, {\n        children: \"port\"\n      }), \" variable to the value of the \", _jsx(_components.strong, {\n        children: \"PORT\"\n      }), \" environment variable, or 3000 if the variable is not set.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Conclusion\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Using environment variables to store configuration information is a best practice when building Dockerized Node.js applications. In this article, we've explored how to set environment variables in Docker using the \", _jsx(_components.strong, {\n        children: \"ENV\"\n      }), \" instruction, the \", _jsx(_components.strong, {\n        children: \"--env\"\n      }), \" flag, and a \", _jsx(_components.strong, {\n        children: \".env\"\n      }), \" file. We've also seen how to access environment variables in Node.js using the \", _jsx(_components.strong, {\n        children: \"process.env\"\n      }), \" object. By using environment variables, you can keep your application configuration separate from your application code, making it easier to deploy and more secure.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"How to Use Environment Variables with Dockerized Node.js Applications","metaDesc":"If you're building a Node.js application that will be deployed using Docker, you'll likely need to make use of environment variables to provide configuration details such as database URLs, API keys, and other sensitive data. In this article, we'll explore how to use environment variables with Dockerized Node.js applications.","tags":["node js"],"slug":"how-to-use-environment-variables-with-dockerized-node-js-applications","readTime":3,"img":"https://images.pexels.com/photos/11035380/pexels-photo-11035380.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1","author":{"data":{"id":1,"attributes":{"username":"vishwesh","email":"vishwesh.singh1991@gmail.com","provider":"local","confirmed":false,"blocked":false,"createdAt":"2023-04-30T11:12:14.071Z","updatedAt":"2023-04-30T11:12:14.071Z"}}}},"__N_SSG":true}