{"pageProps":{"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    strong: \"strong\",\n    code: \"code\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"React is a popular JavaScript library for building web applications. It allows developers to create reusable components that can be used throughout the application. However, as the application grows in size, it can become slower to load. One way to optimize performance is by implementing lazy loading of components.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lazy loading is a technique that loads only the necessary components when they are needed. This helps reduce the initial load time of the application and improves overall performance. In this article, we will explore the techniques and examples of lazy loading components in React.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"What is Lazy Loading?\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lazy loading is a technique used in web development to defer the loading of non-critical resources until they are needed. This is done to reduce the initial load time of the application and improve performance.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the context of React, lazy loading is used to load only the components that are needed at runtime. This can be particularly useful for large web applications that have many components.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Lazy Loading Components in React\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In React, lazy loading of components can be achieved using the \", _jsx(_components.strong, {\n        children: \"React.lazy()\"\n      }), \" function. This function allows us to load a component lazily when it is needed.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here is an example of how to use \", _jsx(_components.strong, {\n        children: \"React.lazy()\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"javascriptCopy code\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"MyComponent\"\n      }), \" \", _jsx(_components.code, {\n        children: \"=\"\n      }), \" \", _jsx(_components.code, {\n        children: \"React``.``lazy``(() =>\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import``(``'./MyComponent'``));\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this example, we are importing a component called \", _jsx(_components.strong, {\n        children: \"MyComponent\"\n      }), \" using the \", _jsx(_components.strong, {\n        children: \"import()\"\n      }), \" function. This function returns a Promise that resolves to the module containing the exported component. The \", _jsx(_components.strong, {\n        children: \"React.lazy()\"\n      }), \" function takes this Promise as an argument and returns a new component that can be rendered lazily.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.strong, {\n        children: \"React.lazy()\"\n      }), \" function also allows us to define a fallback component that can be rendered while the lazily loaded component is being loaded. Here is an example:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"javascriptCopy code\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"MyComponent\"\n      }), \" \", _jsx(_components.code, {\n        children: \"=\"\n      }), \" \", _jsx(_components.code, {\n        children: \"React``.``lazy``(() =>\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import``(``'./MyComponent'``));\"\n      }), \" \", _jsx(_components.code, {\n        children: \"function\"\n      }), \" \", _jsx(_components.code, {\n        children: \"App``() {\"\n      }), \" \", _jsx(_components.code, {\n        children: \"return\"\n      }), \" \", _jsx(_components.code, {\n        children: \"(    <div>      <Suspense\"\n      }), \" \", _jsx(_components.code, {\n        children: \"fallback``=``{``<``div``>Loading...</div>}>        <MyComponent />      </Suspense>    </div>  ); }\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this example, we are using the \", _jsx(_components.strong, {\n        children: \"Suspense\"\n      }), \" component to specify a fallback component that will be rendered while the \", _jsx(_components.strong, {\n        children: \"MyComponent\"\n      }), \" component is being loaded. The \", _jsx(_components.strong, {\n        children: \"Suspense\"\n      }), \" component is a new feature in React 16.6 that allows us to declaratively specify a loading state for a component.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Techniques for Lazy Loading Components\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are several techniques that can be used for lazy loading components in React. In this section, we will explore some of the most common techniques.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.strong, {\n        children: \"Route-based Lazy Loading\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Route-based lazy loading is a technique that involves loading only the components that are needed for a particular route. This can be particularly useful for large web applications that have many routes.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here is an example of how to implement route-based lazy loading using the \", _jsx(_components.strong, {\n        children: \"React.lazy()\"\n      }), \" function:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"javascriptCopy code\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"import\"\n      }), \" \", _jsx(_components.code, {\n        children: \"{ lazy }\"\n      }), \" \", _jsx(_components.code, {\n        children: \"from\"\n      }), \" \", _jsx(_components.code, {\n        children: \"'react'``;\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import\"\n      }), \" \", _jsx(_components.code, {\n        children: \"{\"\n      }), \" \", _jsx(_components.code, {\n        children: \"Route\"\n      }), \" \", _jsx(_components.code, {\n        children: \"}\"\n      }), \" \", _jsx(_components.code, {\n        children: \"from\"\n      }), \" \", _jsx(_components.code, {\n        children: \"'react-router-dom'``;\"\n      }), \" \", _jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"HomePage\"\n      }), \" \", _jsx(_components.code, {\n        children: \"=\"\n      }), \" \", _jsx(_components.code, {\n        children: \"lazy``(() =>\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import``(``'./pages/HomePage'``));\"\n      }), \" \", _jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"AboutPage\"\n      }), \" \", _jsx(_components.code, {\n        children: \"=\"\n      }), \" \", _jsx(_components.code, {\n        children: \"lazy``(() =>\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import``(``'./pages/AboutPage'``));\"\n      }), \" \", _jsx(_components.code, {\n        children: \"function\"\n      }), \" \", _jsx(_components.code, {\n        children: \"App``() {\"\n      }), \" \", _jsx(_components.code, {\n        children: \"return\"\n      }), \" \", _jsx(_components.code, {\n        children: \"(    <div>      <Route\"\n      }), \" \", _jsx(_components.code, {\n        children: \"exact\"\n      }), \" \", _jsx(_components.code, {\n        children: \"path``=``\\\"/\\\"\"\n      }), \" \", _jsx(_components.code, {\n        children: \"component``=``{HomePage}\"\n      }), \" \", _jsx(_components.code, {\n        children: \"/>      <Route\"\n      }), \" \", _jsx(_components.code, {\n        children: \"path``=``\\\"/about\\\"\"\n      }), \" \", _jsx(_components.code, {\n        children: \"component``=``{AboutPage}\"\n      }), \" \", _jsx(_components.code, {\n        children: \"/>    </div>  ); }\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this example, we are using the \", _jsx(_components.strong, {\n        children: \"lazy()\"\n      }), \" function to lazily load the \", _jsx(_components.strong, {\n        children: \"HomePage\"\n      }), \" and \", _jsx(_components.strong, {\n        children: \"AboutPage\"\n      }), \" components. We are then using the \", _jsx(_components.strong, {\n        children: \"Route\"\n      }), \" component from the \", _jsx(_components.strong, {\n        children: \"react-router-dom\"\n      }), \" library to specify the routes and components to be rendered.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.strong, {\n        children: \"Component-based Lazy Loading\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Component-based lazy loading is a technique that involves loading only the components that are needed for a particular component. This can be particularly useful for large components that have many sub-components.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here is an example of how to implement component-based lazy loading using the \", _jsx(_components.strong, {\n        children: \"React.lazy()\"\n      }), \" function:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"javascriptCopy code\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"SubComponent1\"\n      }), \" \", _jsx(_components.code, {\n        children: \"=\"\n      }), \" \", _jsx(_components.code, {\n        children: \"React``.``lazy``(() =>\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import``(``'./SubComponent1'``));\"\n      }), \" \", _jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"SubComponent2\"\n      }), \" \", _jsx(_components.code, {\n        children: \"=\"\n      }), \" \", _jsx(_components.code, {\n        children: \"React``.``lazy``(() =>\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import``(``'./SubComponent2'``));\"\n      }), \" \", _jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"SubComponent3\"\n      }), \" \", _jsx(_components.code, {\n        children: \"=\"\n      }), \" \", _jsx(_components.code, {\n        children: \"React``.``lazy``(() =>\"\n      }), \" \", _jsx(_components.code, {\n        children: \"import``(``'./SubComponent3'``));\"\n      }), \" \", _jsx(_components.code, {\n        children: \"function\"\n      }), \" \", _jsx(_components.code, {\n        children: \"MyComponent``() {\"\n      }), \" \", _jsx(_components.code, {\n        children: \"return\"\n      }), \" \", _jsx(_components.code, {\n        children: \"(    <div>      <h2>My Component</h2>      <Suspense\"\n      }), \" \", _jsx(_components.code, {\n        children: \"fallback``=``{``<``div``>Loading...</div>}>        <SubComponent1 />        <SubComponent2 />        <SubComponent3 />      </Suspense>    </div>  ); }\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this example, we are using the \", _jsx(_components.strong, {\n        children: \"lazy()\"\n      }), \" function to lazily load the \", _jsx(_components.strong, {\n        children: \"SubComponent1\"\n      }), \", \", _jsx(_components.strong, {\n        children: \"SubComponent2\"\n      }), \", and \", _jsx(_components.strong, {\n        children: \"SubComponent3\"\n      }), \" components. We are then using the \", _jsx(_components.strong, {\n        children: \"Suspense\"\n      }), \" component to specify a fallback component that will be rendered while the sub-components are being loaded.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.strong, {\n        children: \"Intersection Observer\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Intersection Observer is a new API that allows us to observe when an element enters or exits the viewport. This can be particularly useful for lazy loading components that are below the fold.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is an example of how to use Intersection Observer to lazy load components:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"javascriptCopy code\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"import\"\n      }), \" \", _jsx(_components.code, {\n        children: \"{ useEffect, useRef, useState }\"\n      }), \" \", _jsx(_components.code, {\n        children: \"from\"\n      }), \" \", _jsx(_components.code, {\n        children: \"'react'``;\"\n      }), \" \", _jsx(_components.code, {\n        children: \"function\"\n      }), \" \", _jsx(_components.code, {\n        children: \"LazyComponent``() {\"\n      }), \" \", _jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"[isVisible, setIsVisible] =\"\n      }), \" \", _jsx(_components.code, {\n        children: \"useState``(``false``);\"\n      }), \" \", _jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"ref =\"\n      }), \" \", _jsx(_components.code, {\n        children: \"useRef``(``null``);\"\n      }), \" \", _jsx(_components.code, {\n        children: \"useEffect``(() => {\"\n      }), \" \", _jsx(_components.code, {\n        children: \"const\"\n      }), \" \", _jsx(_components.code, {\n        children: \"observer =\"\n      }), \" \", _jsx(_components.code, {\n        children: \"new\"\n      }), \" \", _jsx(_components.code, {\n        children: \"IntersectionObserver``(([entry]) => {\"\n      }), \" \", _jsx(_components.code, {\n        children: \"setIsVisible``(entry.isIntersecting);    });    observer.``observe``(ref.current);\"\n      }), \" \", _jsx(_components.code, {\n        children: \"return\"\n      }), \" \", _jsx(_components.code, {\n        children: \"() => {      observer.``unobserve``(ref.current);    };  }, []);\"\n      }), \" \", _jsx(_components.code, {\n        children: \"return\"\n      }), \" \", _jsx(_components.code, {\n        children: \"(    <div\"\n      }), \" \", _jsx(_components.code, {\n        children: \"ref``=``{ref}``>      {isVisible && <h2>Lazy Component</h2>}    </div>  ); }\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this example, we are using the \", _jsx(_components.strong, {\n        children: \"useEffect()\"\n      }), \" hook to create a new \", _jsx(_components.strong, {\n        children: \"IntersectionObserver\"\n      }), \" and observe the \", _jsx(_components.strong, {\n        children: \"ref\"\n      }), \" element. When the element enters the viewport, the \", _jsx(_components.strong, {\n        children: \"isVisible\"\n      }), \" state is set to true and the component is rendered.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Conclusion\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this article, we explored the techniques and examples of lazy loading components in React. We saw how lazy loading can be used to optimize performance by loading only the necessary components when they are needed. We also explored the different techniques that can be used for lazy loading, such as route-based lazy loading, component-based lazy loading, and Intersection Observer.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By using these techniques, you can improve the performance of your React application and provide a better user experience for your users.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Lazy Loading Components in React: Techniques and Examples","metaDesc":"React is a popular front-end library for building user interfaces. It is known for its performance, but it can become slow when loading large components. This is where lazy loading comes in. Lazy loading is a technique used to defer the loading of non-critical parts of an application until they are needed. In this article, we will explore the techniques and examples of lazy loading components in React.\n\n","tags":["react"],"slug":"lazy-loading-components-in-react-techniques-and-examples","readTime":"5","img":"https://images.pexels.com/photos/11035471/pexels-photo-11035471.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1","author":{"data":{"id":1,"attributes":{"username":"vishwesh","email":"vishwesh.singh1991@gmail.com","provider":"local","confirmed":false,"blocked":false,"createdAt":"2023-04-30T11:12:14.071Z","updatedAt":"2023-04-30T11:12:14.071Z"}}}},"__N_SSG":true}