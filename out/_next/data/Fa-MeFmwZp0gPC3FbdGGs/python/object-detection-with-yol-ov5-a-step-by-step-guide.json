{"pageProps":{"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Object detection is a fundamental task in computer vision, and it has numerous applications such as autonomous driving, video surveillance, and image search. With the recent advances in deep learning, object detection has become easier and more accurate than ever before. In this guide, we will introduce you to YOLOv5, one of the most popular object detection algorithms, and walk you through the steps of training your own object detection model.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"What is YOLOv5?\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"YOLOv5 is the latest version of the You Only Look Once (YOLO) algorithm family, which is a real-time object detection system. The YOLOv5 algorithm is based on a single deep neural network and can detect objects with high accuracy and speed. YOLOv5 is an improvement over the previous versions of YOLO in terms of accuracy and speed, and it is also more flexible and easier to use.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Installing YOLOv5\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Before we can start using YOLOv5, we need to install it on our machine. YOLOv5 can be installed on Windows, Linux, and macOS, and it requires Python 3.8 or later. The easiest way to install YOLOv5 is by using pip, the Python package installer. To install YOLOv5, open a terminal window and type the following command:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"pip install yolov5\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This command will install the YOLOv5 package and all its dependencies.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Preparing the Dataset\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first step in training an object detection model is to prepare the dataset. The dataset should contain images of the objects we want to detect, and each image should be annotated with the bounding boxes of the objects. There are several tools available for annotating images, such as LabelImg and VGG Image Annotator (VIA).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once the images are annotated, we need to split the dataset into training, validation, and test sets. The training set is used to train the model, the validation set is used to tune the hyperparameters of the model, and the test set is used to evaluate the performance of the model.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Creating the Configuration File\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After preparing the dataset, we need to create a configuration file for the YOLOv5 model. The configuration file specifies the architecture of the model, the dataset, and the training parameters. The configuration file is written in YAML format and can be edited using any text editor.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here is an example of a configuration file:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsxs(_components.code, {\n        className: \"language-plaintext\",\n        children: [_jsx(_components.span, {\n          className: \"code-line\",\n          children: \"# YOLOv5 configuration file\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"model:\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Model architecture\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  architecture: yolov5s\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Number of classes\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  num_classes: 5\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"train:\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Path to the training dataset\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  train_dataset: ./data/train.yaml\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Path to the validation dataset\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  val_dataset: ./data/val.yaml\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Number of epochs\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  epochs: 50\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Batch size\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  batch_size: 16\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Learning rate\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  lr: 0.001\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"test:\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  # Path to the test dataset\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"  test_dataset: ./data/test.yaml\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this example, we are using the yolov5s architecture, which is the smallest version of YOLOv5. We are training the model to detect 5 classes, and we are using a training dataset and a validation dataset. We are training the model for 50 epochs with a batch size of 16, and a learning rate of 0.001. We also have a test dataset for evaluating the performance of the model.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Training the Model\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once we have prepared the dataset and created the configuration file, we can train the model. To train the model, we need to run the following command in the terminal:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"python train.py --img 640 --batch 16 --epochs 50 --data path/to/data.yaml --cfg path/to/model.yaml --weights yolov5s.pt --name my_experiment\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this command, we are specifying the image size, batch size, number of epochs, path to the data configuration file, path to the model configuration file, path to the pre-trained weights, and the name of the experiment. The pre-trained weights are used to initialize the model, and they can be downloaded from the YOLOv5 repository.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"During the training process, the model will learn to detect the objects in the images and optimize its parameters to minimize the loss function. The loss function measures the difference between the predicted bounding boxes and the ground truth bounding boxes.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Evaluating the Model\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After training the model, we can evaluate its performance on the test set. To evaluate the model, we need to run the following command in the terminal:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"python test.py --weights runs/exp/my_experiment/weights/best.pt --data path/to/data.yaml --img-size 640\\n\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this command, we are specifying the path to the trained weights, path to the data configuration file, and the image size. The best weights are selected based on the performance on the validation set, and they are saved in the \", _jsx(_components.strong, {\n        children: \"runs/exp/my_experiment/weights/\"\n      }), \" directory.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The test script will generate a set of metrics such as precision, recall, and mAP (mean Average Precision) that measure the performance of the model.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Using the Model for Inference\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once we have trained the model and evaluated its performance, we can use it for object detection on new images. To do this, we need to run the following command in the terminal:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-plaintext\",\n      children: _jsx(_components.code, {\n        className: \"language-plaintext\",\n        children: _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"python detect.py --weights runs/exp/my_experiment/weights/best.pt --img-size 640 --source path/to/images --save-txt\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this command, we are specifying the path to the trained weights, image size, path to the images, and the option to save the results as text files. The detect script will detect the objects in the images and save the results in a text file for each image.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: _jsx(_components.strong, {\n        children: \"Conclusion\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this guide, we introduced you to YOLOv5, one of the most popular object detection algorithms, and walked you through the steps of training your own object detection model. We covered the installation of YOLOv5, preparation of the dataset, creation of the configuration file, training of the model, evaluation of the model, and using the model for inference. With this guide, you should now have a good understanding of how to use YOLOv5 for object detection.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"title":"Object Detection with YOLOv5: A Step-by-Step Guide","metaDesc":"Object detection is a fundamental task in computer vision, and it has numerous applications such as autonomous driving, video surveillance, and image search. With the recent advances in deep learning, object detection has become easier and more accurate than ever before. In this guide, we will introduce you to YOLOv5, one of the most popular object detection algorithms, and walk you through the steps of training your own object detection model.","tags":["python"],"slug":"object-detection-with-yol-ov5-a-step-by-step-guide","readTime":5,"img":"https://images.pexels.com/photos/574070/pexels-photo-574070.jpeg","author":{"data":{"id":1,"attributes":{"username":"vishwesh","email":"vishwesh.singh1991@gmail.com","provider":"local","confirmed":false,"blocked":false,"createdAt":"2023-04-30T11:12:14.071Z","updatedAt":"2023-04-30T11:12:14.071Z"}}}},"__N_SSG":true}